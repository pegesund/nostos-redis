# Nostos Redis Extension
#
# Async Redis client. Operations are non-blocking - they spawn an async task
# that performs the Redis operation and sends the result to the caller's mailbox.
#
# Usage:
#   import redis
#   use redis.*
#
#   # Connect to Redis (synchronous - blocks briefly)
#   conn = redisConnect("redis://127.0.0.1/")
#
#   # Operations return result via receive
#   redisSet(conn, "mykey", "myvalue")
#   ("ok", _) = receive { msg -> msg }
#
#   redisGet(conn, "mykey")
#   ("ok", value) = receive { msg -> msg }
#   println("Got: " ++ value)

# =============================================================================
# Connection Type
# =============================================================================

# Connection handle - opaque type from extension
# Note: The handle is untyped as it's managed by the native extension

# =============================================================================
# Connection Management
# =============================================================================

# Connect to Redis (synchronous - blocks during initial connection)
# Returns connection handle
pub redisConnect(url: String) = __native__("Redis.connect", url)

# =============================================================================
# Key-Value Operations (Async - result sent via message)
# =============================================================================

# GET key - retrieve value
# Sends: (ok, value) or (ok, None) if not found, or (error, msg)
pub redisGetAsync(conn, key: String) = __native__("Redis.get", conn, key)

# SET key value
# Sends: (ok, "OK") or (error, msg)
pub redisSetAsync(conn, key: String, value: String) = __native__("Redis.set", conn, key, value)

# DEL key(s) - delete one or more keys
# Sends: (ok, count) or (error, msg)
pub redisDelAsync(conn, key: String) = __native__("Redis.del", conn, key)
pub redisDelManyAsync(conn, keys: List) = __native__("Redis.del", conn, keys)

# EXISTS key - check if key exists
# Sends: (ok, Bool) or (error, msg)
pub redisExistsAsync(conn, key: String) = __native__("Redis.exists", conn, key)

# =============================================================================
# Blocking Wrappers (call + receive for convenience)
# =============================================================================

# GET key - retrieve value
# Returns: (ok, value) or (ok, None) if not found, or (error, msg)
pub redisGet(conn, key: String) = {
    __native__("Redis.get", conn, key)
    receive { msg -> msg }
}

# SET key value
# Returns: (ok, "OK") or (error, msg)
pub redisSet(conn, key: String, value: String) = {
    __native__("Redis.set", conn, key, value)
    receive { msg -> msg }
}

# DEL key(s) - delete one or more keys
# Returns: (ok, count) or (error, msg)
pub redisDel(conn, key: String) = {
    __native__("Redis.del", conn, key)
    receive { msg -> msg }
}

pub redisDelMany(conn, keys: List) = {
    __native__("Redis.del", conn, keys)
    receive { msg -> msg }
}

# EXISTS key - check if key exists
# Returns: (ok, Bool) or (error, msg)
pub redisExists(conn, key: String) = {
    __native__("Redis.exists", conn, key)
    receive { msg -> msg }
}

# =============================================================================
# Key Operations
# =============================================================================

# KEYS pattern - find keys matching pattern (use with caution in production!)
# Returns: (ok, List[String]) or (error, msg)
pub redisKeys(conn, pattern: String) = {
    __native__("Redis.keys", conn, pattern)
    receive { msg -> msg }
}

# EXPIRE key seconds - set TTL
# Returns: (ok, Bool) or (error, msg)
pub redisExpire(conn, key: String, seconds: Int) = {
    __native__("Redis.expire", conn, key, seconds)
    receive { msg -> msg }
}

# TTL key - get remaining TTL (-1 if no expiry, -2 if not exists)
# Returns: (ok, Int) or (error, msg)
pub redisTtl(conn, key: String) = {
    __native__("Redis.ttl", conn, key)
    receive { msg -> msg }
}

# RENAME key newkey - rename a key
# Returns: (ok, "OK") or (error, msg)
pub redisRename(conn, key: String, newkey: String) = {
    __native__("Redis.rename", conn, key, newkey)
    receive { msg -> msg }
}

# TYPE key - get type of key (string, list, set, zset, hash, stream)
# Returns: (ok, String) or (error, msg)
pub redisType(conn, key: String) = {
    __native__("Redis.type", conn, key)
    receive { msg -> msg }
}

# =============================================================================
# Counter Operations
# =============================================================================

# INCR key - increment by 1
# Returns: (ok, new_value) or (error, msg)
pub redisIncr(conn, key: String) = {
    __native__("Redis.incr", conn, key)
    receive { msg -> msg }
}

# INCRBY key amount - increment by amount
# Returns: (ok, new_value) or (error, msg)
pub redisIncrby(conn, key: String, amount: Int) = {
    __native__("Redis.incrby", conn, key, amount)
    receive { msg -> msg }
}

# DECR key - decrement by 1
# Returns: (ok, new_value) or (error, msg)
pub redisDecr(conn, key: String) = {
    __native__("Redis.decr", conn, key)
    receive { msg -> msg }
}

# DECRBY key amount - decrement by amount
# Returns: (ok, new_value) or (error, msg)
pub redisDecrby(conn, key: String, amount: Int) = {
    __native__("Redis.decrby", conn, key, amount)
    receive { msg -> msg }
}

# =============================================================================
# List Operations
# =============================================================================

# LPUSH key value - push to head
# Returns: (ok, length) or (error, msg)
pub redisLpush(conn, key: String, value: String) = {
    __native__("Redis.lpush", conn, key, value)
    receive { msg -> msg }
}

# RPUSH key value - push to tail
# Returns: (ok, length) or (error, msg)
pub redisRpush(conn, key: String, value: String) = {
    __native__("Redis.rpush", conn, key, value)
    receive { msg -> msg }
}

# LPOP key - pop from head
# Returns: (ok, value) or (error, msg)
pub redisLpop(conn, key: String) = {
    __native__("Redis.lpop", conn, key)
    receive { msg -> msg }
}

# RPOP key - pop from tail
# Returns: (ok, value) or (error, msg)
pub redisRpop(conn, key: String) = {
    __native__("Redis.rpop", conn, key)
    receive { msg -> msg }
}

# LRANGE key start stop - get range (0-indexed, -1 means last)
# Returns: (ok, List[String]) or (error, msg)
pub redisLrange(conn, key: String, start: Int, stop: Int) = {
    __native__("Redis.lrange", conn, key, start, stop)
    receive { msg -> msg }
}

# LLEN key - get list length
# Returns: (ok, length) or (error, msg)
pub redisLlen(conn, key: String) = {
    __native__("Redis.llen", conn, key)
    receive { msg -> msg }
}

# =============================================================================
# Hash Operations
# =============================================================================

# HSET key field value
# Returns: (ok, Int) - 1 if new field, 0 if updated, or (error, msg)
pub redisHset(conn, key: String, field: String, value: String) = {
    __native__("Redis.hset", conn, key, field, value)
    receive { msg -> msg }
}

# HGET key field
# Returns: (ok, value) or (error, msg)
pub redisHget(conn, key: String, field: String) = {
    __native__("Redis.hget", conn, key, field)
    receive { msg -> msg }
}

# HDEL key field
# Returns: (ok, count) or (error, msg)
pub redisHdel(conn, key: String, field: String) = {
    __native__("Redis.hdel", conn, key, field)
    receive { msg -> msg }
}

# HGETALL key - returns list of (field, value) tuples
# Returns: (ok, List[(String, String)]) or (error, msg)
pub redisHgetall(conn, key: String) = {
    __native__("Redis.hgetall", conn, key)
    receive { msg -> msg }
}

# HMSET key fields - set multiple fields at once
# fields: List of (field, value) tuples
# Returns: (ok, "OK") or (error, msg)
pub redisHmset(conn, key: String, fields: List) = {
    __native__("Redis.hmset", conn, key, fields)
    receive { msg -> msg }
}

# HMGET key fields - get multiple fields
# fields: List of field names
# Returns: (ok, List[String]) or (error, msg)
pub redisHmget(conn, key: String, fields: List) = {
    __native__("Redis.hmget", conn, key, fields)
    receive { msg -> msg }
}

# HINCRBY key field amount - increment hash field by amount
# Returns: (ok, new_value) or (error, msg)
pub redisHincrby(conn, key: String, field: String, amount: Int) = {
    __native__("Redis.hincrby", conn, key, field, amount)
    receive { msg -> msg }
}

# HKEYS key - get all field names
# Returns: (ok, List[String]) or (error, msg)
pub redisHkeys(conn, key: String) = {
    __native__("Redis.hkeys", conn, key)
    receive { msg -> msg }
}

# HVALS key - get all values
# Returns: (ok, List[String]) or (error, msg)
pub redisHvals(conn, key: String) = {
    __native__("Redis.hvals", conn, key)
    receive { msg -> msg }
}

# HLEN key - get number of fields
# Returns: (ok, Int) or (error, msg)
pub redisHlen(conn, key: String) = {
    __native__("Redis.hlen", conn, key)
    receive { msg -> msg }
}

# HEXISTS key field - check if field exists
# Returns: (ok, Bool) or (error, msg)
pub redisHexists(conn, key: String, field: String) = {
    __native__("Redis.hexists", conn, key, field)
    receive { msg -> msg }
}

# =============================================================================
# Set Operations
# =============================================================================

# SADD key member - add to set
# Returns: (ok, 1) if added, (ok, 0) if already exists, or (error, msg)
pub redisSadd(conn, key: String, member: String) = {
    __native__("Redis.sadd", conn, key, member)
    receive { msg -> msg }
}

# SREM key member - remove from set
# Returns: (ok, count) or (error, msg)
pub redisSrem(conn, key: String, member: String) = {
    __native__("Redis.srem", conn, key, member)
    receive { msg -> msg }
}

# SMEMBERS key - get all members
# Returns: (ok, List[String]) or (error, msg)
pub redisSmembers(conn, key: String) = {
    __native__("Redis.smembers", conn, key)
    receive { msg -> msg }
}

# SISMEMBER key member - check membership
# Returns: (ok, Bool) or (error, msg)
pub redisSismember(conn, key: String, member: String) = {
    __native__("Redis.sismember", conn, key, member)
    receive { msg -> msg }
}

# SCARD key - get set size
# Returns: (ok, Int) or (error, msg)
pub redisScard(conn, key: String) = {
    __native__("Redis.scard", conn, key)
    receive { msg -> msg }
}

# SUNION keys - union of multiple sets
# keys: List of key names
# Returns: (ok, List[String]) or (error, msg)
pub redisSunion(conn, keys: List) = {
    __native__("Redis.sunion", conn, keys)
    receive { msg -> msg }
}

# SINTER keys - intersection of multiple sets
# keys: List of key names
# Returns: (ok, List[String]) or (error, msg)
pub redisSinter(conn, keys: List) = {
    __native__("Redis.sinter", conn, keys)
    receive { msg -> msg }
}

# SDIFF keys - difference of sets (first minus rest)
# keys: List of key names
# Returns: (ok, List[String]) or (error, msg)
pub redisSdiff(conn, keys: List) = {
    __native__("Redis.sdiff", conn, keys)
    receive { msg -> msg }
}

# =============================================================================
# Sorted Set Operations
# =============================================================================

# ZADD key score member - add member with score
# Returns: (ok, Int) - number of elements added, or (error, msg)
pub redisZadd(conn, key: String, score: Float, member: String) = {
    __native__("Redis.zadd", conn, key, score, member)
    receive { msg -> msg }
}

# ZSCORE key member - get score of member
# Returns: (ok, Float) or (error, msg)
pub redisZscore(conn, key: String, member: String) = {
    __native__("Redis.zscore", conn, key, member)
    receive { msg -> msg }
}

# ZRANK key member - get rank (0-indexed, lowest score first)
# Returns: (ok, Int) or (error, msg)
pub redisZrank(conn, key: String, member: String) = {
    __native__("Redis.zrank", conn, key, member)
    receive { msg -> msg }
}

# ZRANGE key start stop - get members by rank (low to high)
# Returns: (ok, List[String]) or (error, msg)
pub redisZrange(conn, key: String, start: Int, stop: Int) = {
    __native__("Redis.zrange", conn, key, start, stop)
    receive { msg -> msg }
}

# ZREVRANGE key start stop - get members by rank (high to low)
# Returns: (ok, List[String]) or (error, msg)
pub redisZrevrange(conn, key: String, start: Int, stop: Int) = {
    __native__("Redis.zrevrange", conn, key, start, stop)
    receive { msg -> msg }
}

# ZINCRBY key increment member - increment score
# Returns: (ok, new_score) or (error, msg)
pub redisZincrby(conn, key: String, increment: Float, member: String) = {
    __native__("Redis.zincrby", conn, key, increment, member)
    receive { msg -> msg }
}

# ZCARD key - get number of members
# Returns: (ok, Int) or (error, msg)
pub redisZcard(conn, key: String) = {
    __native__("Redis.zcard", conn, key)
    receive { msg -> msg }
}

# ZCOUNT key min max - count members with score in range
# Returns: (ok, Int) or (error, msg)
pub redisZcount(conn, key: String, min: Float, max: Float) = {
    __native__("Redis.zcount", conn, key, min, max)
    receive { msg -> msg }
}

# =============================================================================
# Stream Operations
# =============================================================================

# XADD stream fields - add entry to stream (auto-generated ID)
# fields: List of (field, value) tuples
# Returns: (ok, entry_id) or (error, msg)
pub redisXadd(conn, stream: String, fields: List) = {
    __native__("Redis.xadd", conn, stream, fields)
    receive { msg -> msg }
}

# XLEN stream - get number of entries
# Returns: (ok, Int) or (error, msg)
pub redisXlen(conn, stream: String) = {
    __native__("Redis.xlen", conn, stream)
    receive { msg -> msg }
}

# XRANGE stream start end - get entries by ID range (- for min, + for max)
# Returns: (ok, List[...]) or (error, msg)
pub redisXrange(conn, stream: String, startId: String, endId: String) = {
    __native__("Redis.xrange", conn, stream, startId, endId)
    receive { msg -> msg }
}

# XREAD - read entries from streams
# streams: List of (stream_name, last_id) tuples - use "0" for all, "$" for new only
# count: optional max entries per stream
# blockMs: optional blocking timeout in milliseconds (0 = block forever)
# Returns: (ok, List[(stream, entries)]) or (error, msg)
pub redisXread(conn, streams: List) = {
    __native__("Redis.xread", conn, streams)
    receive { msg -> msg }
}

pub redisXreadCount(conn, streams: List, count: Int) = {
    __native__("Redis.xread", conn, streams, count)
    receive { msg -> msg }
}

pub redisXreadBlock(conn, streams: List, count: Int, blockMs: Int) = {
    __native__("Redis.xread", conn, streams, count, blockMs)
    receive { msg -> msg }
}

# =============================================================================
# Stream Consumer Groups
# =============================================================================

# XGROUP CREATE - create a consumer group
# stream: the stream name
# group: the group name
# startId: where to start reading ("0" for beginning, "$" for new entries only)
# mkstream: if true, create the stream if it doesn't exist
# Returns: (ok, "OK") or (error, msg)
pub redisXgroupCreate(conn, stream: String, group: String, startId: String) = {
    __native__("Redis.xgroup_create", conn, stream, group, startId)
    receive { msg -> msg }
}

pub redisXgroupCreateMkstream(conn, stream: String, group: String, startId: String) = {
    __native__("Redis.xgroup_create", conn, stream, group, startId, true)
    receive { msg -> msg }
}

# XREADGROUP - read entries as a consumer in a group
# group: consumer group name
# consumer: consumer name (identifies this reader)
# streams: List of (stream_name, id) tuples - use ">" for new messages
# Returns: (ok, List[(stream, entries)]) or (error, msg)
pub redisXreadgroup(conn, group: String, consumer: String, streams: List) = {
    __native__("Redis.xreadgroup", conn, group, consumer, streams)
    receive { msg -> msg }
}

pub redisXreadgroupCount(conn, group: String, consumer: String, streams: List, count: Int) = {
    __native__("Redis.xreadgroup", conn, group, consumer, streams, count)
    receive { msg -> msg }
}

pub redisXreadgroupBlock(conn, group: String, consumer: String, streams: List, count: Int, blockMs: Int) = {
    __native__("Redis.xreadgroup", conn, group, consumer, streams, count, blockMs)
    receive { msg -> msg }
}

# XACK - acknowledge message processing
# stream: the stream name
# group: the consumer group name
# ids: List of message IDs to acknowledge
# Returns: (ok, count) - number of messages acknowledged
pub redisXack(conn, stream: String, group: String, ids: List) = {
    __native__("Redis.xack", conn, stream, group, ids)
    receive { msg -> msg }
}

# XINFO GROUPS - get info about consumer groups on a stream
# Returns: (ok, List[group_info]) or (error, msg)
pub redisXinfoGroups(conn, stream: String) = {
    __native__("Redis.xinfo_groups", conn, stream)
    receive { msg -> msg }
}

# =============================================================================
# Pub/Sub
# =============================================================================

# PUBLISH channel message
# Returns: (ok, receiver_count) or (error, msg)
pub redisPublish(conn, channel: String, message: String) = {
    __native__("Redis.publish", conn, channel, message)
    receive { msg -> msg }
}

# SUBSCRIBE - subscribe to a channel
# This spawns a background listener that sends messages to caller's mailbox
# Messages arrive as: ("message", channel, payload) or ("pmessage", pattern, channel, payload)
# Returns: (ok, "subscribed") on success, or (error, msg) on failure
# The returned subscription handle can be used to unsubscribe
pub redisSubscribe(url: String, channel: String) = {
    __native__("Redis.subscribe", url, channel)
    receive { msg -> msg }
}

# PSUBSCRIBE - subscribe to channels matching a pattern
# Pattern uses * as wildcard (e.g., "news.*" matches "news.sports", "news.tech")
# Returns: (ok, "subscribed") on success
pub redisPsubscribe(url: String, pattern: String) = {
    __native__("Redis.psubscribe", url, pattern)
    receive { msg -> msg }
}

# =============================================================================
# Utility
# =============================================================================

# PING - test connection
# Returns: (ok, "PONG") or (error, msg)
pub redisPing(conn) = {
    __native__("Redis.ping", conn)
    receive { msg -> msg }
}

# FLUSHDB - clear current database (DANGER!)
# Returns: (ok, "OK") or (error, msg)
pub redisFlushdb(conn) = {
    __native__("Redis.flushdb", conn)
    receive { msg -> msg }
}

# =============================================================================
# Helper Functions
# =============================================================================

# Unwrap a Redis result, panicking on error
pub unwrapRedis(result) = match result {
    ("ok", value) -> value,
    ("error", msg) -> throw("Redis error: " ++ show(msg))
}

# Check if Redis result is ok
pub isRedisOk(result) -> Bool = match result {
    ("ok", _) -> true,
    _ -> false
}

# Get error message from Redis result, or None if ok
pub redisError(result) = match result {
    ("error", msg) -> Some(msg),
    _ -> None
}
